from rest_framework import viewsets
from .models import UserDetail
from .serializers import UserDetailSerializer
import openai
import json
from django.http import JsonResponse
from django.views.decorators.csrf import csrf_exempt
from django.conf import settings
import re
import time
import logging
from rest_framework.response import Response
from rest_framework.status import HTTP_200_OK, HTTP_400_BAD_REQUEST

class UserViewSet(viewsets.ModelViewSet):
    queryset = UserDetail.objects.all()
    serializer_class = UserDetailSerializer
    
    # üîπ Kh·ªüi t·∫°o client OpenAI theo chu·∫©n m·ªõi nh·∫•t
client = openai.OpenAI(api_key=settings.OPENAI_API_KEY)

@csrf_exempt
def summarize_text_hierarchical(request):
    """
    API nh·∫≠n vƒÉn b·∫£n d√†i t·ª´ request, g·ª≠i ƒë·∫øn OpenAI v√† tr·∫£ v·ªÅ JSON ph√¢n c·∫•p.
    H·ªó tr·ª£ 3 ch·∫ø ƒë·ªô t√≥m t·∫Øt: basic, normal, detailed.
    """
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request method"}, status=400)

    try:
        # üîπ L·∫•y n·ªôi dung t·ª´ request
        data = json.loads(request.body)
        input_text = data.get("text", "").strip()
        mode = data.get("mode", "normal").strip().lower()  # Default: normal

        if not input_text:
            return JsonResponse({"error": "Vui l√≤ng nh·∫≠p vƒÉn b·∫£n!"}, status=400)

        # üìå Ch·ªçn prompt t√πy theo ch·∫ø ƒë·ªô
        if mode == "basic":
            prompt = f"""
            H√£y t√≥m t·∫Øt n·ªôi dung sau theo c√°ch ng·∫Øn g·ªçn nh·∫•t, ch·ªâ gi·ªØ l·∫°i nh·ªØng √Ω ch√≠nh l·ªõn.
            
            N·ªôi dung:
            {input_text}
            
            Xu·∫•t ra JSON h·ª£p l·ªá v·ªõi ƒë·ªãnh d·∫°ng sau:
            ```json
            {{
              "title": "Ch·ªß ƒë·ªÅ ch√≠nh",
              "children": [
                {{"title": "√ù ch√≠nh 1"}},
                {{"title": "√ù ch√≠nh 2"}}
              ]
            }}
            ```
            """
        elif mode == "detailed":
            prompt = f"""
            H√£y t√≥m t·∫Øt n·ªôi dung sau m·ªôt c√°ch chi ti·∫øt, c√≥ ph√¢n c·∫•p ƒë·∫ßy ƒë·ªß, gi·∫£i th√≠ch t·ª´ng √Ω v√† ƒë∆∞a v√≠ d·ª• n·∫øu c·∫ßn.
            
            N·ªôi dung:
            {input_text}
            
            Xu·∫•t ra JSON h·ª£p l·ªá v·ªõi ƒë·ªãnh d·∫°ng sau:
            ```json
            {{
              "title": "Ch·ªß ƒë·ªÅ ch√≠nh",
              "children": [
                {{
                  "title": "√ù ch√≠nh 1",
                  "children": [
                    {{"title": "Gi·∫£i th√≠ch chi ti·∫øt 1"}},
                    {{"title": "V√≠ d·ª• 1"}}
                  ]
                }},
                {{
                  "title": "√ù ch√≠nh 2",
                  "children": [
                    {{"title": "Gi·∫£i th√≠ch chi ti·∫øt 2"}},
                    {{"title": "V√≠ d·ª• 2"}}
                  ]
                }}
              ]
            }}
            ```
            """
        else:  # Default: normal
            prompt = f"""
            H√£y t√≥m t·∫Øt n·ªôi dung sau theo d·∫°ng ph√¢n c·∫•p, ƒë·∫ßy ƒë·ªß nh∆∞ng kh√¥ng qu√° chi ti·∫øt.
            
            N·ªôi dung:
            {input_text}
            
            Xu·∫•t ra JSON h·ª£p l·ªá v·ªõi ƒë·ªãnh d·∫°ng sau:
            ```json
            {{
              "title": "Ch·ªß ƒë·ªÅ ch√≠nh",
              "children": [
                {{
                  "title": "√ù ch√≠nh 1",
                  "children": [
                    {{"title": "√ù ph·ª• 1.1"}},
                    {{"title": "√ù ph·ª• 1.2"}}
                  ]
                }},
                {{
                  "title": "√ù ch√≠nh 2",
                  "children": [
                    {{"title": "√ù ph·ª• 2.1"}},
                    {{"title": "√ù ph·ª• 2.2"}}
                  ]
                }}
              ]
            }}
            ```
            """

        # üìå G·ª≠i y√™u c·∫ßu ƒë·∫øn OpenAI API
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1500  # Gi·ªõi h·∫°n s·ªë token ƒë·ªÉ ƒë·∫£m b·∫£o ph·∫£n h·ªìi ƒë·∫ßy ƒë·ªß
        )

        # üìå L·∫•y n·ªôi dung ph·∫£n h·ªìi t·ª´ API
        summary_json = response.choices[0].message.content.strip()

        # üîç Lo·∫°i b·ªè d·∫•u ```json ... ```
        summary_json_cleaned = re.sub(r"```json|```", "", summary_json).strip()

        # üìå Chuy·ªÉn k·∫øt qu·∫£ t·ª´ chu·ªói JSON v·ªÅ d·∫°ng Python dictionary
        try:
            summary_dict = json.loads(summary_json_cleaned)
        except json.JSONDecodeError:
            return JsonResponse({"error": "OpenAI tr·∫£ v·ªÅ d·ªØ li·ªáu kh√¥ng ƒë√∫ng JSON", "raw_response": summary_json_cleaned}, status=500)

        return JsonResponse({"status": "success", "summary": summary_dict, "mode": mode}, json_dumps_params={'ensure_ascii': False})

    except json.JSONDecodeError:
        return JsonResponse({"error": "Invalid JSON format"}, status=400)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)

@csrf_exempt
def generate_exercises(request):
    """
    API nh·∫≠n vƒÉn b·∫£n v√† lo·∫°i b√†i t·∫≠p (multiple_choice, fill_in_the_blank, short_answer)
    v√† t·∫°o b√†i t·∫≠p t∆∞∆°ng ·ª©ng.
    """
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request method"}, status=400)

    try:
        # üîπ Nh·∫≠n d·ªØ li·ªáu t·ª´ body JSON
        data = json.loads(request.body)
        text = data.get("text", "").strip()
        exercise_type = data.get("type", "").strip().lower()  # Lo·∫°i b√†i t·∫≠p

        if not text:
            return JsonResponse({"error": "Vui l√≤ng nh·∫≠p n·ªôi dung ƒë·ªÉ t·∫°o b√†i t·∫≠p"}, status=400)

        if exercise_type not in ["multiple_choice", "fill_in_the_blank", "short_answer"]:
            return JsonResponse({"error": "Lo·∫°i b√†i t·∫≠p kh√¥ng h·ª£p l·ªá"}, status=400)

        # üìå T·∫°o prompt t∆∞∆°ng ·ª©ng v·ªõi t·ª´ng lo·∫°i b√†i t·∫≠p
        if exercise_type == "multiple_choice":
            prompt = f"""
            T·∫°o nhi·ªÅu b√†i t·∫≠p tr·∫Øc nghi·ªám (multiple choice) d·ª±a tr√™n n·ªôi dung sau:
            
            {text}
            
            Xu·∫•t ra JSON d·∫°ng sau:
            ```json
            {{
              "type": "multiple_choice",
              "question": "C√¢u h·ªèi?",
              "options": ["A", "B", "C", "D"],
              "correct_answer": "ƒê√°p √°n ƒë√∫ng"
            }}
            ```
            Ch·ªâ tr·∫£ v·ªÅ JSON h·ª£p l·ªá.
            """

        elif exercise_type == "fill_in_the_blank":
            prompt = f"""
            T·∫°o nhi·ªÅu b√†i t·∫≠p ƒëi·ªÅn v√†o ch·ªó tr·ªëng (fill in the blank) d·ª±a tr√™n n·ªôi dung sau:
            
            {text}
            
            Xu·∫•t ra JSON d·∫°ng sau:
            ```json
            {{
              "type": "fill_in_the_blank",
              "question": "C√¢u n√†y c√≥ m·ªôt t·ª´ b·ªã thi·∫øu: _____ l√† m·ªôt c√¥ng ngh·ªá AI.",
              "correct_answer": "H·ªçc m√°y"
            }}
            ```
            Ch·ªâ tr·∫£ v·ªÅ JSON h·ª£p l·ªá.
            """

        elif exercise_type == "short_answer":
            prompt = f"""
            T·∫°o nhi·ªÅu c√¢u h·ªèi t·ª± lu·∫≠n ng·∫Øn (short answer) d·ª±a tr√™n n·ªôi dung sau:
            
            {text}
            
            Xu·∫•t ra JSON d·∫°ng sau:
            ```json
            {{
              "type": "short_answer",
              "question": "H·ªçc m√°y l√† g√¨?"
            }}
            ```
            Ch·ªâ tr·∫£ v·ªÅ JSON h·ª£p l·ªá.
            """

        # üìå G·ª≠i y√™u c·∫ßu l√™n OpenAI API
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=500
        )

        # üîπ L·∫•y k·∫øt qu·∫£ t·ª´ OpenAI v√† x·ª≠ l√Ω JSON
        exercises_json = response.choices[0].message.content.strip()
        exercises_json_cleaned = re.sub(r"```json|```", "", exercises_json).strip()
        exercises_dict = json.loads(exercises_json_cleaned)

        return JsonResponse({"status": "success", "exercise": exercises_dict}, json_dumps_params={'ensure_ascii': False})

    except json.JSONDecodeError:
        return JsonResponse({"error": "Ph·∫£n h·ªìi t·ª´ OpenAI kh√¥ng ƒë√∫ng JSON"}, status=500)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)


import logging

logger = logging.getLogger(__name__)  # üìå Kh·ªüi t·∫°o logger

@csrf_exempt
def summarize_text_short(request):
    """
    API nh·∫≠n vƒÉn b·∫£n d√†i t·ª´ request, g·ª≠i ƒë·∫øn OpenAI v√† tr·∫£ v·ªÅ n·ªôi dung ƒë√£ ƒë∆∞·ª£c t√≥m t·∫Øt.
    """
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request method"}, status=400)

    try:
        # üìå L·∫•y n·ªôi dung t·ª´ request
        data = json.loads(request.body)
        input_text = data.get("text", "").strip()

        if not input_text:
            return JsonResponse({"error": "Vui l√≤ng nh·∫≠p vƒÉn b·∫£n!"}, status=400)

        # üìå Prompt t√≥m t·∫Øt vƒÉn b·∫£n + t·∫°o ti√™u ƒë·ªÅ
        prompt = f"""
        B·∫°n l√† m·ªôt chuy√™n gia t√≥m t·∫Øt. 
        H√£y t√≥m t·∫Øt n·ªôi dung sau ƒë·∫ßy ƒë·ªß √Ω ch√≠nh, kh√¥ng b·ªè qua th√¥ng tin quan tr·ªçng.

        VƒÉn b·∫£n: {input_text}

        Tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON v·ªõi ƒë√∫ng c·∫•u tr√∫c sau:
        {{
            "title": "Ti√™u ƒë·ªÅ ng·∫Øn (2-4 ch·ªØ)",
            "summary": "Ph·∫ßn t√≥m t·∫Øt n·ªôi dung ch√≠nh, d·ªÖ hi·ªÉu"
        }}
        Ch·ªâ tr·∫£ v·ªÅ JSON h·ª£p l·ªá, kh√¥ng c√≥ vƒÉn b·∫£n n√†o kh√°c.
        """

        # üìå G·ª≠i y√™u c·∫ßu ƒë·∫øn OpenAI API
        response = client.chat.completions.create(
            model="gpt-4o-mini",
            messages=[{"role": "user", "content": prompt}],
            max_tokens=300,  # Gi·ªõi h·∫°n ƒë·ªô d√†i t√≥m t·∫Øt
            response_format={"type": "json_object"}  # ‚úÖ ƒê·ªãnh d·∫°ng ƒë√∫ng ki·ªÉu JSON
        )

        # üìå Ghi log ph·∫£n h·ªìi g·ªëc t·ª´ OpenAI
        logger.info(f"üîπ Response t·ª´ AI: {response}")

        # üìå L·∫•y n·ªôi dung ph·∫£n h·ªìi (chu·ªói JSON)
        response_data = response.choices[0].message.content
        logger.info(f"üîπ N·ªôi dung ph·∫£n h·ªìi AI: {response_data}")  # Log chi ti·∫øt ph·∫£n h·ªìi

        # üìå Chuy·ªÉn chu·ªói JSON th√†nh dictionary
        try:
            parsed_data = json.loads(response_data)
            title = parsed_data.get("title", "").strip()
            summary = parsed_data.get("summary", "").strip()
        except json.JSONDecodeError:
            logger.error("‚ö†Ô∏è Ph·∫£n h·ªìi t·ª´ AI kh√¥ng ph·∫£i JSON h·ª£p l·ªá!")  # Ghi log l·ªói
            return JsonResponse({"error": "Ph·∫£n h·ªìi t·ª´ AI kh√¥ng ph·∫£i JSON h·ª£p l·ªá"}, status=500)

        return JsonResponse({
            "status": "success",
            "title": title,
            "summary": summary
        }, json_dumps_params={'ensure_ascii': False})

    except json.JSONDecodeError:
        logger.error("‚ö†Ô∏è L·ªói JSON t·ª´ request!")  # Ghi log l·ªói JSON
        return JsonResponse({"error": "Invalid JSON format"}, status=400)
    except Exception as e:
        logger.exception(f"‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}")  # Ghi log l·ªói chi ti·∫øt
        return JsonResponse({"error": str(e)}, status=500)
      
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)      
      
@csrf_exempt
def chat_with_ai(request):
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request method"}, status=400)

    try:
        data = json.loads(request.body)
        user_id = data.get("idUser")
        chu_de_id = data.get("idChuDe")
        user_message = data.get("message", "").strip()

        if not user_id or not chu_de_id or not user_message:
            return JsonResponse({"error": "Vui l√≤ng nh·∫≠p idUser, idChuDe v√† tin nh·∫Øn!"}, status=400)

        # üìå L·∫•y ch·ªß ƒë·ªÅ
        try:
            chu_de = ChuDe.objects.get(id=chu_de_id)
        except ChuDe.DoesNotExist:
            return JsonResponse({"error": "Ch·ªß ƒë·ªÅ kh√¥ng t·ªìn t·∫°i"}, status=404)

        # üìå T·∫°o ho·∫∑c l·∫•y thread ID
        danh_gia, created = DanhGia.objects.get_or_create(
            idUser_id=user_id,
            idChuDe_id=chu_de_id,
            defaults={"idThread": None, "soCauHoi": 0}  # ‚ûú Kh·ªüi t·∫°o s·ªë c√¢u h·ªèi l√† 0
        )

        if danh_gia.idThread is None:
            # üîπ T·∫°o thread m·ªõi
            thread = client.beta.threads.create()
            danh_gia.idThread = thread.id
            danh_gia.soCauHoi = 0  # Reset s·ªë c√¢u h·ªèi
            danh_gia.save()

            # üè∑ G·ª≠i tin nh·∫Øn SYSTEM v·ªõi n·ªôi dung ch·ªß ƒë·ªÅ
            context_message = f"""
            B·∫°n l√† m·ªôt gia s∆∞ th√¥ng minh, h·ªó tr·ª£ sinh vi√™n v·ªÅ ch·ªß ƒë·ªÅ: {chu_de.name_chu_de}.
            N·ªôi dung ch·ªß ƒë·ªÅ: {chu_de.noi_dung}

            ‚úÖ Tr·∫£ l·ªùi NG·∫ÆN G·ªåN, t·ªëi ƒëa 2-3 c√¢u.
            ‚úÖ Kh√¥ng lan man, ch·ªâ n√≥i v·ªÅ ch·ªß ƒë·ªÅ n√†y.
            ‚úÖ N·∫øu c√¢u h·ªèi n·∫±m ngo√†i ph·∫°m vi ch·ªß ƒë·ªÅ, h√£y t·ª´ ch·ªëi tr·∫£ l·ªùi.
            
            üìå Sau khi sinh vi√™n h·ªèi 4 c√¢u, h√£y ƒë∆∞a ra nh·∫≠n x√©t:
            - ƒêi·ªÉm m·∫°nh trong c√¢u tr·∫£ l·ªùi c·ªßa sinh vi√™n.
            - N·ªôi dung c√≤n y·∫øu c·∫ßn c·∫£i thi·ªán.
            - M·ª©c ƒë·ªô ti·∫øn b·ªô so v·ªõi tr∆∞·ªõc.
            - ƒê·ªông vi√™n v√† h∆∞·ªõng d·∫´n c√°ch c·∫£i thi·ªán.
            """

            client.beta.threads.messages.create(
                thread_id=thread.id,
                role="assistant",
                content=context_message
            )

        thread_id = danh_gia.idThread  # üìå L·∫•y thread_id hi·ªán t·∫°i

        # üìå Ki·ªÉm tra s·ªë c√¢u h·ªèi ƒë·ªÉ quy·∫øt ƒë·ªãnh c√≥ nh·∫≠n x√©t hay kh√¥ng
        if danh_gia.soCauHoi >= 4:
            # üéØ Y√™u c·∫ßu AI ƒë√°nh gi√° sinh vi√™n
            feedback_message = """
            ƒê√°nh gi√° t·ªïng quan sau 4 c√¢u h·ªèi:
            - ƒêi·ªÉm m·∫°nh trong c√¢u tr·∫£ l·ªùi c·ªßa sinh vi√™n.
            - N·ªôi dung c√≤n y·∫øu c·∫ßn c·∫£i thi·ªán.
            - M·ª©c ƒë·ªô ti·∫øn b·ªô so v·ªõi tr∆∞·ªõc.
            - ƒê·ªông vi√™n v√† h∆∞·ªõng d·∫´n c√°ch c·∫£i thi·ªán.
            """
            
            client.beta.threads.messages.create(
                thread_id=thread_id,
                role="user",
                content=feedback_message
            )

            danh_gia.soCauHoi = 0  # üîÑ Reset s·ªë c√¢u h·ªèi sau khi ƒë√°nh gi√°
            danh_gia.save()
        else:
            # üìå G·ª≠i tin nh·∫Øn c·ªßa ng∆∞·ªùi d√πng
            client.beta.threads.messages.create(
                thread_id=thread_id,
                role="user",
                content=user_message
            )

            danh_gia.soCauHoi += 1  # ‚ûï TƒÉng s·ªë c√¢u h·ªèi
            danh_gia.save()

        # üìå Ch·∫°y Assistant v·ªõi gi·ªõi h·∫°n n·ªôi dung
        run = client.beta.threads.runs.create(
            thread_id=thread_id,
            assistant_id=settings.OPENAI_ASSISTANT_ID,
            instructions=f"Ch·ªâ tr·∫£ l·ªùi trong ph·∫°m vi ch·ªß ƒë·ªÅ '{chu_de.name_chu_de}'. Kh√¥ng lan man."
        )

        # ‚è≥ Ch·ªù ph·∫£n h·ªìi t·ª´ AI
        while run.status in ["queued", "in_progress"]:
            time.sleep(1)
            run = client.beta.threads.runs.retrieve(thread_id=thread_id, run_id=run.id)

        if run.status == "failed":
            error_message = run.last_error.message if hasattr(run.last_error, "message") else "Kh√¥ng c√≥ chi ti·∫øt l·ªói."
            return JsonResponse({"error": f"AI kh√¥ng th·ªÉ x·ª≠ l√Ω y√™u c·∫ßu! Chi ti·∫øt: {error_message}"}, status=500)

        # üìå L·∫•y ph·∫£n h·ªìi AI
        messages = client.beta.threads.messages.list(thread_id=thread_id)
        ai_messages = [msg for msg in messages.data if msg.role == "assistant"]
        if not ai_messages:
            return JsonResponse({"error": "AI kh√¥ng ph·∫£n h·ªìi!"}, status=500)

        ai_response = ai_messages[0].content[0].text.value  # üè∑ Ch·ªâ l·∫•y c√¢u tr·∫£ l·ªùi g·∫ßn nh·∫•t

        return JsonResponse({
            "status": "success",
            "thread_id": thread_id,
            "response": ai_response
        }, json_dumps_params={'ensure_ascii': False})

    except json.JSONDecodeError:
        return JsonResponse({"error": "D·ªØ li·ªáu JSON kh√¥ng h·ª£p l·ªá"}, status=400)
    except Exception as e:
        return JsonResponse({"error": str(e)}, status=500)
      
from rest_framework import viewsets
from .models import UserDetail, ChuDe, File, DanhGia
from .serializers import UserDetailSerializer, ChuDeSerializer, FileSerializer, DanhGiaSerializer

class UserDetailViewSet(viewsets.ModelViewSet):
    queryset = UserDetail.objects.all()
    serializer_class = UserDetailSerializer

class ChuDeViewSet(viewsets.ModelViewSet):
    queryset = ChuDe.objects.all()
    serializer_class = ChuDeSerializer

class FileViewSet(viewsets.ModelViewSet):
    queryset = File.objects.all()
    serializer_class = FileSerializer

class DanhGiaViewSet(viewsets.ModelViewSet):
    queryset = DanhGia.objects.all()
    serializer_class = DanhGiaSerializer

from rest_framework.decorators import api_view
@api_view(['POST'])
def check_user(request):
    username = request.data.get('username')
    password = request.data.get('password')
    
    if not username or not password:
        return Response({'message': 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß username v√† password'}, status=400)
    
    user = UserDetail.objects.filter(lastName=username, password=password).first()
    
    if user:
        return Response({'id': user.idUser})
    
    return Response({'message': 'T√†i kho·∫£n kh√¥ng t·ªìn t·∫°i'}, status=404)
@api_view(['POST'])
def register_user(request):
    username = request.data.get('username')  # lastName s·∫Ω ƒë√≥ng vai tr√≤ username
    email = request.data.get('email')
    password = request.data.get('password')

    if not username or not email or not password:
        return Response({'message': 'Vui l√≤ng nh·∫≠p ƒë·∫ßy ƒë·ªß username, email v√† password'}, status=400)
    
    # Ki·ªÉm tra xem email ƒë√£ t·ªìn t·∫°i ch∆∞a
    if UserDetail.objects.filter(email=email).exists():
        return Response({'message': 'Email ƒë√£ ƒë∆∞·ª£c s·ª≠ d·ª•ng'}, status=400)

    # T·∫°o ng∆∞·ªùi d√πng m·ªõi
    user = UserDetail.objects.create(
        lastName=username,  
        firstName='a',  # Lu√¥n l√† "a"
        email=email,
        password=password # M√£ h√≥a m·∫≠t kh·∫©u
    )

    return Response({'message': 'ƒêƒÉng k√Ω th√†nh c√¥ng', 'id': user.idUser}, status=201)

def split_text(text, max_length=1000):
    """
    Chia vƒÉn b·∫£n th√†nh c√°c ƒëo·∫°n nh·ªè ƒë·ªÉ tr√°nh b·ªã c·∫Øt khi t√≥m t·∫Øt.
    """
    sentences = text.split('. ')
    chunks, chunk = [], ""
    for sentence in sentences:
        if len(chunk) + len(sentence) < max_length:
            chunk += sentence + ". "
        else:
            chunks.append(chunk.strip())
            chunk = sentence + ". "
    if chunk:
        chunks.append(chunk.strip())
    return chunks

def summarize_chunk(text_chunk):
    """
    G·ª≠i ƒëo·∫°n vƒÉn b·∫£n nh·ªè ƒë·∫øn OpenAI ƒë·ªÉ t√≥m t·∫Øt.
    """
    prompt = f"""
    B·∫°n l√† m·ªôt chuy√™n gia ng√¥n ng·ªØ. H√£y t√≥m t·∫Øt vƒÉn b·∫£n sau m·ªôt c√°ch s√∫c t√≠ch nh∆∞ng gi·ªØ nguy√™n c√°c √Ω ch√≠nh quan tr·ªçng.

    üìå **Y√™u c·∫ßu:**
    - T√≥m t·∫Øt ƒë·∫ßy ƒë·ªß √Ω ch√≠nh, kh√¥ng b·ªè qua th√¥ng tin quan tr·ªçng.
    - VƒÉn phong d·ªÖ hi·ªÉu, ph√π h·ª£p v·ªõi ng∆∞·ªùi ƒë·ªçc ph·ªï th√¥ng.
    - Ph·∫£i gi·ªØ nguy√™n c·∫•u tr√∫c c√¢u quan tr·ªçng ho·∫∑c m·∫°ch √Ω ch√≠nh.
    - Tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON h·ª£p l·ªá v·ªõi c·∫•u tr√∫c:
    {{
        "title": "Ti√™u ƒë·ªÅ ng·∫Øn (3-6 t·ª´)",
        "summary": "T√≥m t·∫Øt ch√≠nh x√°c n·ªôi dung, kh√¥ng d√†i qu√° 150 t·ª´"
    }}

    VƒÉn b·∫£n: {text_chunk}
    """

    try:
        response = client.chat.completions.create(
            model="gpt-4o-mini",  
            messages=[{"role": "user", "content": prompt}],
            max_tokens=1000,  # TƒÉng gi·ªõi h·∫°n ƒë·ªÉ t√≥m t·∫Øt t·ªët h∆°n
            response_format={"type": "json_object"}
        )

        # üìå Ghi log ph·∫£n h·ªìi
        logger.info(f"üîπ Response t·ª´ AI: {response}")

        # üìå L·∫•y n·ªôi dung ph·∫£n h·ªìi JSON
        response_data = response.choices[0].message.content
        parsed_data = json.loads(response_data)

        return parsed_data.get("title", "").strip(), parsed_data.get("summary", "").strip()

    except json.JSONDecodeError:
        logger.error("‚ö†Ô∏è Ph·∫£n h·ªìi t·ª´ AI kh√¥ng ph·∫£i JSON h·ª£p l·ªá!")
        return "", "Ph·∫£n h·ªìi t·ª´ AI kh√¥ng h·ª£p l·ªá"
    except Exception as e:
        logger.exception(f"‚ö†Ô∏è L·ªói OpenAI: {str(e)}")
        return "", "L·ªói khi t√≥m t·∫Øt vƒÉn b·∫£n"
@csrf_exempt
def summarize_text(request):
    """
    API nh·∫≠n vƒÉn b·∫£n d√†i t·ª´ request, chia nh·ªè n·∫øu c·∫ßn, g·ª≠i ƒë·∫øn OpenAI v√† tr·∫£ v·ªÅ n·ªôi dung ƒë√£ ƒë∆∞·ª£c t√≥m t·∫Øt.
    """
    if request.method != "POST":
        return JsonResponse({"error": "Invalid request method"}, status=400)

    try:
        # üìå Nh·∫≠n vƒÉn b·∫£n t·ª´ request
        data = json.loads(request.body)
        input_text = data.get("text", "").strip()

        if not input_text:
            return JsonResponse({"error": "Vui l√≤ng nh·∫≠p vƒÉn b·∫£n!"}, status=400)

        # üìå Chia nh·ªè n·∫øu qu√° d√†i
        text_chunks = split_text(input_text, max_length=1000)
        summaries = []

        for chunk in text_chunks:
            title, summary = summarize_chunk(chunk)
            summaries.append(summary)

        # üìå G·ªôp c√°c ƒëo·∫°n t√≥m t·∫Øt th√†nh m·ªôt ƒëo·∫°n ho√†n ch·ªânh
        final_summary = " ".join(summaries)

        return JsonResponse({
            "status": "success",
            "title": "T√≥m t·∫Øt vƒÉn b·∫£n",
            "summary": final_summary
        }, json_dumps_params={'ensure_ascii': False})

    except json.JSONDecodeError:
        logger.error("‚ö†Ô∏è L·ªói JSON t·ª´ request!")
        return JsonResponse({"error": "Invalid JSON format"}, status=400)
    except Exception as e:
        logger.exception(f"‚ö†Ô∏è L·ªói kh√¥ng x√°c ƒë·ªãnh: {str(e)}")
        return JsonResponse({"error": str(e)}, status=500)